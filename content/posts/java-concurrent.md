---
title: "Revisit Concurrent Programming in Java"
date: 2019-12-28T12:38:25-05:00
draft: true
tags: ['Java', 'Concurrent']
---

Not long ago I went through the "Concurrent Programming in Java" course on Coursera. Though the contents involved are very fundamental, I felt it's necessary to give them a revisit since they are building blocks of more advanced contents in concurrent and distributed world.

# Overview
Overall, I figured this course followed a bottom-up approach. It first introduces low-level Java concurrent primitives, and then go through some of the higher-level approaches that solve some of the problems when programming with the low-level concepts. From that end, it discussed some of the concurrent data structures, and formally introduced linearizability, which is the correctness requirement of any concurrent data structure.

I drew this simple diagram to illustrate the relationships between some basic concurrent concepts/approaches:

![alt test][structure]

[structure]: /images/java-concurrent/PCDP.jpg "course structure"

# Level 1: Threads and Locks
## Thread in Java
In Java, `Thread` is simply a class that implements the `Runnable` interface. Typically we pass in an object that implements `Runnable` to instantiate a `Thread` object.

When separated from application context, there isn't too much to be discussed. But as Java 8 brings in functional programming and lambda expression, understanding some related language-specific details (though most of them might be regarded as syntactic sugar), in my opinion, could be necessary for starters.

One of these things is that Java imposes making local variable of a class `final` if they are to be accessed by lambdas in this class. For example, the snippet below won't compile. There are many online resources for finding the reason for this (like [this article](https://www.baeldung.com/java-lambda-effectively-final-local-variables)), and in general it's primarily because the ways Java manages closures.

```java
public class Test {
    public void createThreadIncorrect(int num) {
        boolean run = true;
        Runnable runnable = () -> {
            System.out.println(num);
            while (run) {
                // Some operations.
            }
        }
        (new Thread(runnable)).start()
        run = false;
    }
}
```

In the above code, we are creating an anonymous class that implements `Runnable` interface. Java will use the autogenerated constructor to create the object, and this constructor will copy the value of `num` and `run` instead of using the `num` and `run` variables themselves. There are two major reasons for this behavior:

1. The compiler doesn't need to generate extra information to hold the state of the variable, which might be easier to do. In contrast, some other languages, like Golang and C#, actually captures the variables themselfs instead of their values.
2. In concurrent situations, things could get messy if `final` is not imposed. For example, in the `while()` loop above, the new thread will try to detect the change of local variable `run`, but since local variables are stored on stack (and different threads will have their own stacks), it's not quite possible to observe the value change of `run` from another thread. Even if we might use `volatile` to make the value change visible to all threads, synchronization will be needed to prevent inconsistency, which brings in more complexity.

## Locks in Java

Locking mechanism in Java can be categorized into two classes: structured locks and unstructured locks. Structured locks basically use the intrinsic locks (which all objects have), and unstructured locks use the lock classes (e.g. ReentrantLock) within the `java.util.concurrent.locks` package.